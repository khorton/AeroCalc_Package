--- ssec.py	(original)
+++ ssec.py	(refactored)
@@ -48,15 +48,15 @@
 """
 Various functions related to static source error correction.
 """
-from __future__ import division
-import airspeed as A
+
+import airspeed as A
 import math as M
-import std_atm as SA
-import unit_conversion as U
-import constants
+import std_atm as SA
+import unit_conversion as U
+import constants
 
 try:
-    from default_units import *
+    from default_units import *
 except ImportError:
     default_area_units = 'ft**2'
     default_power_units = 'hp'
@@ -139,16 +139,15 @@
     if 2 < len(GS) < 5:
         pass
     else:
-        raise ValueError, 'GS must be a list of three or four items'
+        raise ValueError('GS must be a list of three or four items')
 
     if 2 < len(TK) < 5:
         pass
     else:
-        raise ValueError, 'TK must be a list of three or four items'
+        raise ValueError('TK must be a list of three or four items')
 
     if len(GS) != len(TK):
-        raise ValueError, \
-            'The ground speed and track arrays must have the same number of elements.'
+        raise ValueError('The ground speed and track arrays must have the same number of elements.')
 
     if len(GS) == 3:
         result = gps2tas3(GS, TK, verbose)
@@ -200,8 +199,7 @@
                     results[2][1][1]), (results[3][1][0],
                     results[3][1][1])))
         else:
-            raise ValueError, \
-                'The value of verbose must be equal to 0, 1 or 2'
+            raise ValueError('The value of verbose must be equal to 0, 1 or 2')
 
 
 def gps2tas3(GS, TK, verbose=0):
@@ -259,8 +257,7 @@
     elif verbose == 0:
         return TAS
     else:
-        raise ValueError, \
-            'The value of verbose must be equal to 0, 1 or 2'
+        raise ValueError('The value of verbose must be equal to 0, 1 or 2')
 
 
 # #############################################################################
@@ -337,14 +334,14 @@
     oat = U.temp_conv(oat, temp_units, 'C')
     M = A.tas2mach(tas, oat, temp_units='C', speed_units='kt')
     if M > 1:
-        raise ValueError, 'This method only works for Mach < 1'
+        raise ValueError('This method only works for Mach < 1')
     delta_ic = SA.alt2press_ratio(ind_alt, alt_units='ft')
     qcic_over_Psl = A.cas2dp(ias, speed_units='kt', press_units=press_units) / U.press_conv(constants.P0, 'pa', to_units=press_units)
     qcic_over_Ps = qcic_over_Psl / delta_ic
     Mic = A.dp_over_p2mach(qcic_over_Ps)
     delta_mach_pc = M - Mic
     if Mic > 1:
-        raise ValueError, 'This method only works for Mach < 1'
+        raise ValueError('This method only works for Mach < 1')
     deltaPp_over_Ps = (1.4 * delta_mach_pc * (Mic + delta_mach_pc / 2)) / (1 + 0.2 * (Mic + delta_mach_pc / 2 )**2)
     deltaPp_over_qcic = deltaPp_over_Ps / qcic_over_Ps
     delta_Hpc = SA.alt2temp_ratio(std_alt, alt_units='ft') * deltaPp_over_Ps / 3.61382e-5
